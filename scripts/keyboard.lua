-- Set the input of Pleine Lune to the keyboard and press the keys for the first and second octave: upper and lower octave set different cutoff and resonance values of the filter
-- for an extra feature connect output 1 to retrig of the VCF envelope and press the button

-- set the frame division, the script will process at your audio blocksize divided by 8. Lower divisions consume more CPU.
config.frameDivider = 8
config.bufferSize = 8

-- Example of dump generated by the helper dump button, see line 25 and 59
function NewOctave(id)
  mod = Module(id)
  mod.params = {
    ["Shift"] = {index = 0, min = -4.000000, max = 4.000000, default = 0.000000},
  }
  mod.inputs = {
    ["1V/octave pitch"] = {index = 0},
    ["Octave shift CV"] = {index = 1},
  }
  mod.outputs = {
    ["Pitch"] = {index = 0},
  }
  mod.lights = {
  }
  return mod
end

-- modules using there hexadecimal ids
lfo = Module(0x16)
vcf = Module(0x4)
oct = NewOctave(0x12)

-- two very useful premade objects available in all scripts to check when a value "triggers", the .new() syntax is Lua's OOP way
but = BooleanTrigger.new()
upper = BooleanTrigger.new()

-- the process function is what is being run every block
function process(block)
  
  -- MIDI messages are treated here
  for i=1,block.midiInputSize do
    -- for every message we create a new message object to hold the message content
    msg = Message(block.midiInput[i])
    -- display prints to Rack's log file
    display('type ' .. string.format("0x%x", msg.type) .. ' channel ' .. msg.channel .. ' note ' .. msg.note .. ' value ' .. msg.value)
    
    -- here, we "process" a boolean value representing wether we're above the first octave
    -- the handy thing is that it returns true right when it triggers, otherwise it's false
    upper:process(msg.note >= 72)
    -- another handy thing, are we rising from false to true?
    if upper:isRising() then
      display("up!")
      -- take care of the : notation, don't worry, you'll get used to it!
      -- param 0, as per the Helper indicates, is Frequency
      vcf:setParam(0, 0.95)
      -- and param 2 is resonance
      vcf:setParam(2, 0.2)
    end
    -- ... or falling from true to false?
    if upper:isFalling() then
      display("down!")
      -- more colons! just remember that instead of the usual dot, you call functions on objects with : and . (dot) is for accessing tables/structs
      vcf:setParam(0, 0.05)
      vcf:setParam(2, 0.04)
    end
  end
  
  -- print something when the button is clicked
  -- block.button is true when pressed, false otherwise
  if but:process(block.button) then
    display('Button pressed!')
  end
  
  -- to use the input or the outputs, one must fill/read the entire block, so we do a for loop
  for j=1,block.bufferSize do
    -- we use the true/false value directly to send "continous" values
    if block.button then 
      block.outputs[1][j] = 1.0
    else
      block.outputs[1][j] = 0.0
    end
  end
  
  -- here we take advantage of the module dump used at the top of the file, we can use the parameter name directly
  -- turn the left knob to see the effect!
  oct:setParam("Shift", block.knobs[1])
  
  -- read the values from the LFO led and copy it to OUR led!
  block.light[1] = lfo:getLight(0) / 2
  block.light[2] = lfo:getLight(1) / 2
  block.light[3] = lfo:getLight(2) / 2
end
